"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReflectionSymbolId = void 0;
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const tsutils_1 = require("../../utils/tsutils");
/**
 * This exists so that TypeDoc can store a unique identifier for a `ts.Symbol` without
 * keeping a reference to the `ts.Symbol` itself. This identifier should be stable across
 * runs so long as the symbol is exported from the same file.
 */
class ReflectionSymbolId {
    constructor(symbol, declaration) {
        if ("name" in symbol) {
            declaration ?? (declaration = symbol?.declarations?.[0]);
            this.fileName = declaration?.getSourceFile().fileName ?? "\0";
            if (symbol.declarations?.some(typescript_1.default.isSourceFile)) {
                this.qualifiedName = "";
            }
            else {
                this.qualifiedName = (0, tsutils_1.getQualifiedName)(symbol, symbol.name);
            }
            this.pos = declaration?.pos ?? Infinity;
        }
        else {
            this.fileName = symbol.sourceFileName;
            this.qualifiedName = symbol.qualifiedName;
            this.pos = Infinity;
        }
    }
    getStableKey() {
        if (Number.isFinite(this.pos)) {
            return `${this.fileName}\0${this.qualifiedName}\0${this.pos}`;
        }
        else {
            return `${this.fileName}\0${this.qualifiedName}`;
        }
    }
    toObject(serializer) {
        return {
            sourceFileName: (0, path_1.isAbsolute)(this.fileName)
                ? (0, path_1.relative)(serializer.projectRoot, this.fileName)
                : this.fileName,
            qualifiedName: this.qualifiedName,
        };
    }
}
exports.ReflectionSymbolId = ReflectionSymbolId;
//# sourceMappingURL=id.js.map